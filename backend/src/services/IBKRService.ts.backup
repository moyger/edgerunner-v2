import { IBApi, Contract, Order as IBOrder, ErrorCode } from '@stoqey/ib';
import { EventEmitter } from 'events';
import NodeCache from 'node-cache';
import { v4 as uuidv4 } from 'uuid';
import {
  IBKRCredentials,
  ConnectionStatus,
  MarketDataStatus,
  MarketDataSnapshot,
  MarketDataField,
  MarketDataSubscription,
  OrderRequest,
  Order,
  OrderResponse,
  IBKRPosition,
  AccountSummary,
  IBKRError,
  ErrorSeverity,
  Contract as IBKRContract,
  ExecutionReport,
  ConnectionHealth
} from '../types/ibkr';
import { ibkrLogger, logIBKREvent, logOrderEvent, logMarketDataEvent, logError } from '../utils/logger';
import config from '../config';

export class IBKRService extends EventEmitter {
  private api: IBApi | null = null;
  private connectionStatus: ConnectionStatus = 'disconnected';
  private marketDataStatus: MarketDataStatus = 'inactive';
  private credentials: IBKRCredentials | null = null;
  private subscriptions = new Map<string, MarketDataSubscription>();
  private contracts = new Map<string, Contract>();
  private orders = new Map<number, Order>();
  private positions = new Map<string, IBKRPosition>();
  private accountSummary: AccountSummary | null = null;
  private cache = new NodeCache({ stdTTL: config.cache.ttl, maxKeys: config.cache.maxKeys });
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private lastHeartbeat = new Date();
  private nextOrderId = 1;
  private reqIdCounter = 1;

  constructor() {
    super();
    this.setupCleanup();
  }

  // ===== CONNECTION MANAGEMENT =====

  async connect(credentials: IBKRCredentials): Promise<void> {
    try {
      this.credentials = credentials;
      this.setConnectionStatus('connecting');
      
      logIBKREvent('connection_attempt', { 
        host: credentials.host, 
        port: credentials.connectionPort,
        clientId: credentials.clientId,
        isPaper: credentials.isPaper 
      });

      this.api = new IBApi({
        host: credentials.host || config.ibkr.host,
        port: credentials.connectionPort,
        clientId: credentials.clientId
      });

      this.setupEventHandlers();
      
      // Connect with timeout
      await Promise.race([
        this.connectWithRetry(),
        this.createTimeout(config.ibkr.timeout, 'Connection timeout')
      ]);

      this.setConnectionStatus('connected');
      this.reconnectAttempts = 0;
      this.startHeartbeat();
      
      // Request initial data
      await this.requestInitialData();
      
      logIBKREvent('connection_established', { clientId: credentials.clientId });
      this.emit('connected');

    } catch (error) {
      this.setConnectionStatus('error');
      logError(error as Error, { context: 'IBKRService.connect' });
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    try {
      this.setConnectionStatus('disconnected');
      this.setMarketDataStatus('inactive');
      
      if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      }

      if (this.api) {
        this.api.disconnect();
        this.api = null;
      }

      this.clearCaches();
      logIBKREvent('disconnected');
      this.emit('disconnected');

    } catch (error) {
      logError(error as Error, { context: 'IBKRService.disconnect' });
      throw error;
    }
  }

  private async connectWithRetry(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.api) {
        reject(new Error('API not initialized'));
        return;
      }

      const onConnected = () => {
        this.api?.off('connected', onConnected);
        this.api?.off('error', onError);
        resolve();
      };

      const onError = (error: any) => {
        this.api?.off('connected', onConnected);
        this.api?.off('error', onError);
        reject(error);
      };

      this.api.once('connected', onConnected);
      this.api.once('error', onError);
      
      this.api.connect();
    });
  }

  private createTimeout(ms: number, message: string): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error(message)), ms);
    });
  }

  private async reconnect(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      logIBKREvent('max_reconnect_attempts_reached', { attempts: this.reconnectAttempts });
      this.setConnectionStatus('error');
      return;
    }

    this.reconnectAttempts++;
    this.setConnectionStatus('reconnecting');
    
    logIBKREvent('reconnection_attempt', { attempt: this.reconnectAttempts });

    try {
      await new Promise(resolve => setTimeout(resolve, this.reconnectDelay));
      
      if (this.credentials) {
        await this.connect(this.credentials);
      }
    } catch (error) {
      logError(error as Error, { context: 'IBKRService.reconnect' });
      this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // Max 30 seconds
      await this.reconnect();
    }
  }

  // ===== EVENT HANDLERS =====

  private setupEventHandlers(): void {
    if (!this.api) return;

    this.api.on('error', this.handleError.bind(this));
    this.api.on('disconnected', this.handleDisconnected.bind(this));
    
    // Market data events
    this.api.on('tickPrice', this.handleTickPrice.bind(this));
    this.api.on('tickSize', this.handleTickSize.bind(this));
    
    // Order and execution events
    this.api.on('nextValidId', this.handleNextValidId.bind(this));
    this.api.on('orderStatus', this.handleOrderStatus.bind(this));
    this.api.on('openOrder', this.handleOpenOrder.bind(this));
    this.api.on('execDetails', this.handleExecDetails.bind(this));
    
    // Portfolio events
    this.api.on('position', this.handlePosition.bind(this));
    this.api.on('accountSummary', this.handleAccountSummary.bind(this));
    
    // Contract events
    this.api.on('contractDetails', this.handleContractDetails.bind(this));
  }

  private handleError(error: any, code: number, reqId: number): void {
    const severity = this.categorizeError(code);
    const ibkrError: IBKRError = {
      id: reqId,
      code,
      message: error.message || 'Unknown IBKR error',
      severity,
      timestamp: new Date().toISOString(),
      recoverable: this.isRecoverableError(code)
    };

    logError(new Error(ibkrError.message), { 
      context: 'IBKR Error',
      code,
      reqId,
      severity 
    });

    this.emit('error', ibkrError);

    // Handle specific error cases
    if (code === ErrorCode.NOT_CONNECTED || code === ErrorCode.CONNECT_FAIL) {
      this.handleDisconnected();
    }
  }

  private handleDisconnected(): void {
    this.setConnectionStatus('disconnected');
    this.setMarketDataStatus('inactive');
    
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }

    logIBKREvent('connection_lost');
    this.emit('disconnected');

    // Auto-reconnect if we were previously connected
    if (this.credentials && this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => this.reconnect(), this.reconnectDelay);
    }
  }

  private handleNextValidId(orderId: number): void {
    this.nextOrderId = orderId;
    logIBKREvent('next_valid_order_id', { orderId });
  }

  // ===== MARKET DATA =====

  async subscribeToMarketData(symbols: string[], fields: MarketDataField[] = [MarketDataField.LAST, MarketDataField.BID, MarketDataField.ASK]): Promise<string> {
    if (!this.isConnected()) {
      throw new Error('Not connected to IBKR');
    }

    const subscriptionId = uuidv4();
    const subscription: MarketDataSubscription = {
      id: subscriptionId,
      symbols,
      fields,
      frequency: 'streaming',
      active: true,
      onUpdate: (data) => this.emit('marketDataUpdate', data),
      onError: (error) => this.emit('marketDataError', error)
    };

    this.subscriptions.set(subscriptionId, subscription);

    try {
      for (const symbol of symbols) {
        const contract = await this.getOrCreateContract(symbol);
        if (contract && this.api) {
          const reqId = this.getNextReqId();
          this.api.reqMktData(reqId, contract, '', false, false, []);
          logMarketDataEvent('subscription_started', symbol, { reqId, subscriptionId });
        }
      }

      this.setMarketDataStatus('active');
      return subscriptionId;

    } catch (error) {
      this.subscriptions.delete(subscriptionId);
      logError(error as Error, { context: 'subscribeToMarketData', symbols });
      throw error;
    }
  }

  async unsubscribeFromMarketData(subscriptionId: string): Promise<void> {
    const subscription = this.subscriptions.get(subscriptionId);
    if (!subscription) {
      throw new Error('Subscription not found');
    }

    subscription.active = false;
    this.subscriptions.delete(subscriptionId);

    // Cancel market data requests
    // Note: In a full implementation, we'd track reqIds and cancel them
    logMarketDataEvent('subscription_cancelled', '', { subscriptionId });
  }

  private handleTickPrice(tickerId: number, field: number, price: number, canAutoExecute: boolean): void {
    // Find symbol by tickerId - in full implementation, maintain tickerId to symbol mapping
    const symbol = this.findSymbolByTickerId(tickerId);
    if (!symbol) return;

    const snapshot = this.getMarketDataSnapshot(symbol);
    
    switch (field) {
      case MarketDataField.BID:
        snapshot.bid = price;
        break;
      case MarketDataField.ASK:
        snapshot.ask = price;
        break;
      case MarketDataField.LAST:
        snapshot.last = price;
        snapshot.change = price - snapshot.close;
        snapshot.changePercent = snapshot.close ? (snapshot.change / snapshot.close) * 100 : 0;
        break;
      case MarketDataField.HIGH:
        snapshot.high = price;
        break;
      case MarketDataField.LOW:
        snapshot.low = price;
        break;
      case MarketDataField.CLOSE:
        snapshot.close = price;
        break;
      case MarketDataField.OPEN:
        snapshot.open = price;
        break;
    }

    snapshot.timestamp = new Date().toISOString();
    this.cache.set(`market_data_${symbol}`, snapshot);
    
    this.emit('marketDataUpdate', {
      symbol,
      field,
      value: price,
      timestamp: snapshot.timestamp
    });
  }

  private handleTickSize(tickerId: number, field: number, size: number): void {
    const symbol = this.findSymbolByTickerId(tickerId);
    if (!symbol) return;

    const snapshot = this.getMarketDataSnapshot(symbol);
    
    switch (field) {
      case MarketDataField.BID_SIZE:
        snapshot.bidSize = size;
        break;
      case MarketDataField.ASK_SIZE:
        snapshot.askSize = size;
        break;
      case MarketDataField.LAST_SIZE:
        snapshot.lastSize = size;
        break;
      case MarketDataField.VOLUME:
        snapshot.volume = size;
        break;
    }

    snapshot.timestamp = new Date().toISOString();
    this.cache.set(`market_data_${symbol}`, snapshot);
  }

  // ===== ORDER MANAGEMENT =====

  async placeOrder(orderRequest: OrderRequest): Promise<OrderResponse> {
    if (!this.isConnected()) {
      throw new Error('Not connected to IBKR');
    }

    try {
      const contract = await this.getOrCreateContract(orderRequest.symbol);
      if (!contract) {
        throw new Error(`Contract not found for symbol: ${orderRequest.symbol}`);
      }

      const ibOrder: IBOrder = {
        orderId: this.nextOrderId++,
        action: orderRequest.action,
        totalQuantity: orderRequest.quantity,
        orderType: orderRequest.orderType,
        lmtPrice: orderRequest.price,
        auxPrice: orderRequest.auxPrice,
        tif: orderRequest.timeInForce,
        account: orderRequest.accountId || ''
      };

      const order: Order = {
        orderId: ibOrder.orderId,
        permId: 0, // Will be set by IBKR
        symbol: orderRequest.symbol,
        action: orderRequest.action,
        quantity: orderRequest.quantity,
        orderType: orderRequest.orderType,
        price: orderRequest.price,
        auxPrice: orderRequest.auxPrice,
        status: 'PendingSubmit',
        filled: 0,
        remaining: orderRequest.quantity,
        avgFillPrice: 0,
        lastFillPrice: 0,
        commission: 0,
        timestamp: new Date().toISOString(),
        strategyId: orderRequest.strategyId,
        account: orderRequest.accountId || ''
      };

      this.orders.set(ibOrder.orderId, order);

      if (this.api) {
        this.api.placeOrder(ibOrder.orderId, contract, ibOrder);
      }

      logOrderEvent('order_placed', ibOrder.orderId, {
        symbol: orderRequest.symbol,
        action: orderRequest.action,
        quantity: orderRequest.quantity,
        orderType: orderRequest.orderType
      });

      return {
        orderId: ibOrder.orderId,
        status: 'PendingSubmit',
        filled: 0,
        avgFillPrice: 0,
        remaining: orderRequest.quantity,
        timestamp: order.timestamp,
        commission: 0,
        order
      };

    } catch (error) {
      logError(error as Error, { context: 'placeOrder', orderRequest });
      throw error;
    }
  }

  async cancelOrder(orderId: number): Promise<void> {
    if (!this.isConnected()) {
      throw new Error('Not connected to IBKR');
    }

    const order = this.orders.get(orderId);
    if (!order) {
      throw new Error(`Order not found: ${orderId}`);
    }

    if (this.api) {
      this.api.cancelOrder(orderId);
    }

    logOrderEvent('order_cancel_requested', orderId);
  }

  private handleOrderStatus(orderId: number, status: string, filled: number, remaining: number, avgFillPrice: number, permId: number, parentId: number, lastFillPrice: number, clientId: number, whyHeld: string, mktCapPrice: number): void {
    const order = this.orders.get(orderId);
    if (!order) return;

    const wasFullyFilled = order.status === 'Filled';
    
    order.status = status as any;
    order.filled = filled;
    order.remaining = remaining;
    order.avgFillPrice = avgFillPrice;
    order.lastFillPrice = lastFillPrice;
    order.permId = permId;
    order.parentId = parentId;

    this.orders.set(orderId, order);

    logOrderEvent('order_status_update', orderId, {
      status,
      filled,
      remaining,
      avgFillPrice
    });

    this.emit('orderUpdate', order);

    // If order is fully filled and wasn't before, emit fill event
    if (status === 'Filled' && !wasFullyFilled) {
      this.emit('orderFilled', order);
    }
  }

  private handleOpenOrder(orderId: number, contract: Contract, order: IBOrder, orderState: any): void {
    // Update order details from IBKR
    const existingOrder = this.orders.get(orderId);
    if (existingOrder) {
      // Update with additional details from IBKR
      this.orders.set(orderId, existingOrder);
    }
  }

  private handleExecDetails(reqId: number, contract: Contract, execution: any): void {
    const executionReport: ExecutionReport = {
      orderId: execution.orderId,
      execId: execution.execId,
      symbol: contract.symbol,
      side: execution.side,
      shares: execution.shares,
      price: execution.price,
      time: execution.time,
      commission: 0, // Will be updated in commissionReport
      realizedPnL: 0,
      account: execution.acctNumber
    };

    logOrderEvent('execution_report', execution.orderId, {
      execId: execution.execId,
      symbol: contract.symbol,
      shares: execution.shares,
      price: execution.price
    });

    this.emit('executionReport', executionReport);
  }

  // ===== PORTFOLIO MANAGEMENT =====

  private handlePosition(account: string, contract: Contract, position: number, avgCost: number): void {
    const ibkrPosition: IBKRPosition = {
      account,
      symbol: contract.symbol,
      position,
      marketPrice: 0, // Will be updated from market data
      marketValue: 0,
      averageCost: avgCost,
      unrealizedPnL: 0,
      realizedPnL: 0,
      conId: contract.conId
    };

    const key = `${account}_${contract.symbol}`;
    this.positions.set(key, ibkrPosition);

    this.emit('positionUpdate', ibkrPosition);
  }

  private handleAccountSummary(reqId: number, account: string, tag: string, value: string, currency: string): void {
    if (!this.accountSummary) {
      this.accountSummary = {} as AccountSummary;
    }

    // Map IBKR account summary tags to our structure
    switch (tag) {
      case 'NetLiquidation':
        this.accountSummary.netLiquidation = parseFloat(value);
        break;
      case 'TotalCashValue':
        this.accountSummary.totalCashValue = parseFloat(value);
        break;
      case 'BuyingPower':
        this.accountSummary.buyingPower = parseFloat(value);
        break;
      // Add more mappings as needed
    }

    this.emit('accountUpdate', this.accountSummary);
  }

  // ===== CONTRACT MANAGEMENT =====

  private async getOrCreateContract(symbol: string): Promise<Contract | null> {
    let contract = this.contracts.get(symbol);
    
    if (!contract) {
      contract = {
        symbol,
        secType: 'STK',
        exchange: 'SMART',
        currency: 'USD',
        conId: 0
      };

      this.contracts.set(symbol, contract);
      
      // Request contract details to get conId
      if (this.api) {
        const reqId = this.getNextReqId();
        this.api.reqContractDetails(reqId, contract);
      }
    }

    return contract;
  }

  private handleContractDetails(reqId: number, contractDetails: any): void {
    const contract = contractDetails.contract;
    this.contracts.set(contract.symbol, contract);
  }

  // ===== UTILITY METHODS =====

  private async requestInitialData(): Promise<void> {
    if (!this.api) return;

    // Request next valid order ID
    this.api.reqIds(1);

    // Request account summary
    this.api.reqAccountSummary(9001, 'All', 'NetLiquidation,TotalCashValue,BuyingPower');

    // Request positions
    this.api.reqPositions();
  }

  private getMarketDataSnapshot(symbol: string): MarketDataSnapshot {
    const cached = this.cache.get<MarketDataSnapshot>(`market_data_${symbol}`);
    if (cached) return cached;

    const snapshot: MarketDataSnapshot = {
      symbol,
      conId: 0,
      last: 0,
      bid: 0,
      ask: 0,
      high: 0,
      low: 0,
      close: 0,
      volume: 0,
      open: 0,
      bidSize: 0,
      askSize: 0,
      lastSize: 0,
      change: 0,
      changePercent: 0,
      timestamp: new Date().toISOString()
    };

    this.cache.set(`market_data_${symbol}`, snapshot);
    return snapshot;
  }

  private findSymbolByTickerId(tickerId: number): string | null {
    // In a full implementation, maintain a mapping of tickerId to symbol
    // For now, return null and implement proper mapping
    return null;
  }

  private getNextReqId(): number {
    return this.reqIdCounter++;
  }

  private categorizeError(code: number): ErrorSeverity {
    if (code >= 100 && code < 200) return ErrorSeverity.LOW;
    if (code >= 200 && code < 300) return ErrorSeverity.MEDIUM;
    if (code >= 300 && code < 400) return ErrorSeverity.HIGH;
    return ErrorSeverity.CRITICAL;
  }

  private isRecoverableError(code: number): boolean {
    const recoverableCodes = [
      ErrorCode.NOT_CONNECTED,
      ErrorCode.CONNECT_FAIL,
      ErrorCode.TWS_TIME_OR_ORDER_WILL_NOT_PROCESS,
      ErrorCode.REQUEST_TIMED_OUT
    ];
    return recoverableCodes.includes(code);
  }

  private setConnectionStatus(status: ConnectionStatus): void {
    if (this.connectionStatus !== status) {
      this.connectionStatus = status;
      this.emit('connectionStatusChanged', status);
    }
  }

  private setMarketDataStatus(status: MarketDataStatus): void {
    if (this.marketDataStatus !== status) {
      this.marketDataStatus = status;
      this.emit('marketDataStatusChanged', status);
    }
  }

  private startHeartbeat(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }

    this.heartbeatInterval = setInterval(() => {
      this.lastHeartbeat = new Date();
      this.emit('heartbeat');
    }, config.websocket.heartbeatInterval);
  }

  private clearCaches(): void {
    this.cache.flushAll();
    this.subscriptions.clear();
    this.orders.clear();
    this.positions.clear();
    this.contracts.clear();
    this.accountSummary = null;
  }

  private setupCleanup(): void {
    const cleanup = () => {
      this.disconnect().catch(console.error);
    };

    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
    process.on('exit', cleanup);
  }

  // ===== PUBLIC GETTERS =====

  isConnected(): boolean {
    return this.connectionStatus === 'connected';
  }

  getConnectionStatus(): ConnectionStatus {
    return this.connectionStatus;
  }

  getMarketDataStatus(): MarketDataStatus {
    return this.marketDataStatus;
  }

  getConnectionHealth(): ConnectionHealth {
    return {
      isConnected: this.isConnected(),
      lastHeartbeat: this.lastHeartbeat.toISOString(),
      connectionDuration: this.isConnected() ? Date.now() - this.lastHeartbeat.getTime() : 0,
      reconnectAttempts: this.reconnectAttempts,
      dataQuality: this.marketDataStatus === 'active' ? 'good' : 'unavailable'
    };
  }

  getOrders(): Order[] {
    return Array.from(this.orders.values());
  }

  getPositions(): IBKRPosition[] {
    return Array.from(this.positions.values());
  }

  getAccountSummary(): AccountSummary | null {
    return this.accountSummary;
  }

  getMarketData(symbol: string): MarketDataSnapshot | null {
    return this.cache.get(`market_data_${symbol}`) || null;
  }
}